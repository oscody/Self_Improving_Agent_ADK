    📋 SETUP INSTRUCTIONS FOR GOOGLE COLAB:

    1. Install the Gemini API client:
       !pip install google-generativeai

    2. Get your Gemini API key:
       - Go to https://makersuite.google.com/app/apikey
       - Create a new API key
       - Copy the key

    3. Replace 'your-gemini-api-key-here' with your actual API key

    4. Run the code!

    🔧 CUSTOMIZATION OPTIONS:
    - Modify test_problems list to add your own challenges
    - Adjust improvement cycles count
    - Add new capabilities to track
    - Extend the learning mechanisms

    💡 IMPROVEMENT IDEAS:
    - Add persistent memory (save/load agent state)
    - Implement more sophisticated evaluation metrics
    - Add domain-specific problem types
    - Create visualization of improvement over time
    

============================================================
🤖 Self-Improving Agent Demo
This agent will attempt to solve problems and improve over time
🚀 Starting 3 improvement cycles with 5 problems

==================================================
IMPROVEMENT CYCLE 1/3
==================================================

=== Iteration 1 ===
Problem: Write a function to calculate the factorial of a number
Task Analysis: {'task': 'Write a function to calculate the factorial of a number', 'analysis': {'complexity': 2, 'required_skills': ['Basic programming knowledge', 'Understanding of loops (iterative or recursive)', 'Basic arithmetic operations', 'Function definition and usage'], 'potential_challenges': ['Handling edge cases (e.g., factorial of 0, negative numbers)', 'Dealing with large numbers (potential overflow)', 'Choosing between iterative and recursive approaches (performance implications)', 'Error handling (e.g., invalid input type)'], 'recommended_approach': {'steps': ['Define the function signature (input: integer, output: integer)', 'Handle edge cases: factorial of 0 is 1; negative input should raise an error or return an error code.', 'Choose an approach: iterative (generally more efficient for large numbers) or recursive (more concise but can hit stack overflow for very large numbers).', 'Implement the chosen approach using a loop (iterative) or recursive calls.', 'Test the function thoroughly with various inputs, including edge cases.', 'Consider adding input validation to check for the correct data type.'], 'algorithm': {'iterative': 'Initialize result to 1.  Iterate from 1 to n (inclusive), multiplying the result by each number in the iteration.', 'recursive': 'Base case: if n is 0, return 1. Recursive step: return n * factorial(n-1).'}, 'example_code_python': 'def factorial(n):\n  if n < 0:\n    raise ValueError("Factorial is not defined for negative numbers")\n  elif n == 0:\n    return 1\n  else:\n    result = 1\n    for i in range(1, n + 1):\n      result *= i\n    return result'}, 'success_criteria': ['The function should correctly calculate the factorial for non-negative integers.', 'The function should handle the edge case of 0 correctly (factorial of 0 is 1).', 'The function should gracefully handle negative inputs (e.g., raise an exception or return an appropriate error code).', 'The function should be well-documented and easy to understand.', 'The function should pass a comprehensive set of unit tests.']}}
❌ Solution Quality: 0.60 (Needs Improvement)

=== Iteration 2 ===
Problem: Create a simple text-based calculator that handles basic operations
Task Analysis: {'task': 'Create a simple text-based calculator that handles basic operations', 'analysis': {'complexity': 3, 'requiredSkills': ['Basic programming knowledge', 'Understanding of input/output operations', 'Ability to handle user input', 'Familiarity with basic arithmetic operators (+, -, *, /)', 'Basic control flow (if-else statements)', 'String manipulation (optional, for error handling)'], 'potentialChallenges': ['Handling invalid user input (e.g., non-numeric input, division by zero)', 'Implementing robust error handling', 'Designing a user-friendly interface (even in a text-based environment)', 'Choosing appropriate data types to avoid overflow or precision issues', 'Managing the order of operations (PEMDAS/BODMAS)'], 'recommendedApproach': ['Start with a simple design:  Focus on handling addition, subtraction, multiplication, and division first.', 'Use a loop to allow multiple calculations.', 'Implement input validation to catch errors early.', 'Display clear error messages to the user.', 'Consider using functions to modularize the code and improve readability.', 'Test thoroughly with various inputs, including edge cases (e.g., zero, negative numbers, large numbers).', 'Gradually add features like more advanced operations (exponents, square roots) only after the core functionality is working correctly.', 'Document the code clearly.'], 'successCriteria': ['The calculator should correctly perform addition, subtraction, multiplication, and division.', 'The calculator should handle invalid input gracefully (display an error message and prompt for correct input).', 'The calculator should be easy to use (clear prompts and output).', 'The code should be well-structured, readable, and documented.', 'The calculator should run without crashing.']}}
❌ Solution Quality: 0.60 (Needs Improvement)

=== Iteration 3 ===
Problem: Design a system to find the shortest path between two points in a graph
Task Analysis: {'task': 'Design a system to find the shortest path between two points in a graph', 'analysis': {'complexity': 7, 'requiredSkills': ['Graph Theory', 'Algorithm Design (especially searching algorithms)', 'Data Structures (e.g., adjacency matrix, adjacency list)', 'Software Design Principles', 'Problem Solving', 'Programming (in a suitable language like Python, Java, C++)', 'Testing and Debugging'], 'potentialChallenges': ['Handling large graphs (memory and computational efficiency)', 'Dealing with weighted graphs (different edge costs)', 'Handling negative edge weights (potential for infinite loops in some algorithms)', 'Finding the optimal algorithm for specific graph characteristics (sparse vs. dense)', 'Choosing appropriate data structures for efficient performance', 'Implementing efficient handling of graph updates (adding/removing nodes or edges)', 'Testing for correctness and robustness (handling edge cases and invalid inputs)', 'Scalability and performance under high load'], 'recommendedApproach': {'steps': ['1. **Problem Definition:** Clearly define the graph representation (weighted or unweighted, directed or undirected), data structures to be used, and input/output formats.', "2. **Algorithm Selection:** Choose an appropriate shortest path algorithm based on graph characteristics and performance requirements.  Consider Dijkstra's algorithm (for non-negative edge weights), Bellman-Ford algorithm (for graphs with negative edge weights, but detects negative cycles), A* search (for heuristic-informed pathfinding).", '3. **Data Structure Implementation:** Implement the chosen data structure (adjacency matrix or adjacency list) for efficient graph representation.', '4. **Algorithm Implementation:** Implement the selected algorithm using the chosen data structure.', '5. **Testing and Validation:**  Thoroughly test the system with various test cases including small, large, and edge cases (e.g., disconnected graphs, cycles, negative weights). Use unit tests and integration tests.', '6. **Optimization:** Profile the code to identify bottlenecks and optimize for performance (e.g., using more efficient data structures or algorithm implementations).', '7. **Documentation:** Document the system design, algorithms used, data structures, and testing procedures.'], 'algorithmConsiderations': {'Dijkstra': "Efficient for non-negative weighted graphs, but doesn't handle negative edge weights.", 'Bellman-Ford': "Handles negative edge weights, detects negative cycles, but slower than Dijkstra's.", 'A*': 'Best for heuristic-informed search (requires a heuristic function), efficient for large graphs if a good heuristic is available.'}}, 'successCriteria': ['The system correctly finds the shortest path between any two given points in the graph.', 'The system handles various graph types (weighted/unweighted, directed/undirected).', 'The system is computationally efficient and scales well with increasing graph size.', 'The system is robust and handles edge cases and invalid inputs gracefully.', 'The system is well-documented and easy to understand and maintain.']}}
❌ Solution Quality: 0.70 (Needs Improvement)

=== Iteration 4 ===
Problem: Implement a basic recommendation system for movies based on user preferences
Task Analysis: {'task': 'Implement a basic movie recommendation system based on user preferences', 'analysis': {'complexity': 6, 'requiredSkills': ['Python programming (or similar)', 'Data manipulation and cleaning (Pandas, NumPy)', 'Data structures and algorithms', 'Basic understanding of machine learning concepts', 'Familiarity with recommendation algorithms (e.g., collaborative filtering, content-based filtering)', 'Database management (SQL or NoSQL)', 'Model evaluation and selection'], 'potentialChallenges': ['Data sparsity (users may not have rated many movies)', 'Cold start problem (difficulty recommending movies to new users or for new movies)', 'Data quality issues (inconsistent ratings, missing data)', 'Scalability (handling large datasets and user base)', 'Choosing the appropriate recommendation algorithm', 'Evaluating the performance of the recommendation system (measuring accuracy and relevance)'], 'recommendedApproach': ['1. **Data Acquisition and Preprocessing:** Gather movie data (titles, genres, descriptions) and user ratings (e.g., from a public dataset like MovieLens). Clean and preprocess the data, handling missing values and outliers.', '2. **Feature Engineering:** Extract relevant features from the data.  For content-based filtering, this might include genre, director, actors, keywords from descriptions. For collaborative filtering, the ratings themselves are the primary feature.', '3. **Algorithm Selection:** Choose a suitable recommendation algorithm. For a basic system, consider starting with user-based collaborative filtering (calculating similarity between users based on their ratings) or a simple content-based filtering approach (recommending movies similar to ones the user has liked).', "4. **Model Training and Evaluation:** Train the chosen algorithm on the preprocessed data. Split the data into training and testing sets to evaluate the model's performance using metrics like precision, recall, F1-score, or RMSE.", '5. **System Implementation:**  Develop a system (web application, script, etc.) to take user input (e.g., movie ratings, preferences) and generate recommendations using the trained model.', '6. **Deployment and Iteration:** Deploy the system and collect user feedback. Iterate on the system, refining the algorithm, features, and data preprocessing steps based on performance and user feedback.'], 'successCriteria': ['The system generates relevant movie recommendations for a significant portion of users.', 'The system demonstrates acceptable accuracy based on chosen evaluation metrics (e.g., high precision and recall).', 'The system is scalable and performs reasonably well with a larger dataset and increased user base.', 'The system is user-friendly and provides a good user experience.', 'The system is well-documented and maintainable.']}}
❌ Solution Quality: 0.60 (Needs Improvement)

=== Iteration 5 ===
Problem: Create a machine learning model to predict house prices based on features
Task Analysis: {'task': 'Create a machine learning model to predict house prices based on features', 'analysis': {'complexity': 7, 'required_skills': ['Data cleaning and preprocessing', 'Feature engineering', 'Model selection (Regression models: Linear Regression, Ridge, Lasso, ElasticNet, RandomForestRegressor, GradientBoostingRegressor, XGBoost, etc.)', 'Model training and evaluation (metrics: RMSE, MAE, R-squared)', 'Hyperparameter tuning', 'Model deployment (optional)', 'Data visualization', 'Programming skills (Python or R)', 'Understanding of machine learning principles'], 'potential_challenges': ['Data quality issues (missing values, outliers, inconsistencies)', 'Feature selection and engineering (choosing relevant features, creating new features)', 'Handling skewed data', 'Overfitting or underfitting the model', 'Interpretability of the model', 'Finding optimal hyperparameters', 'Generalization to unseen data', 'Dealing with high dimensionality', 'Computational resources for large datasets'], 'recommended_approach': ['1. **Data Acquisition and Exploration:** Gather house price data including relevant features (location, size, age, number of bedrooms/bathrooms etc.). Explore data using descriptive statistics and visualizations to understand its characteristics.', '2. **Data Preprocessing:** Clean the data by handling missing values (imputation or removal), outliers (handling/removal), and transforming categorical features (one-hot encoding, label encoding).', '3. **Feature Engineering:** Create new features that might improve model performance (e.g., combining features, calculating ratios).', '4. **Feature Selection:** Select the most relevant features using techniques like correlation analysis or feature importance scores from tree-based models.', '5. **Model Selection:** Choose appropriate regression models based on data characteristics and desired model interpretability. Start with simpler models and progressively explore more complex ones.', '6. **Model Training and Evaluation:** Split the data into training, validation, and testing sets. Train the chosen models on the training set, tune hyperparameters using the validation set, and evaluate performance on the testing set using appropriate metrics (RMSE, MAE, R-squared).', '7. **Model Deployment (Optional):** Deploy the best-performing model to a production environment for making predictions on new data.  This may involve creating an API or integrating the model into an existing system.', '8. **Iteration and Refinement:** Continuously improve the model by experimenting with different features, models, and hyperparameters based on performance evaluation.'], 'success_criteria': ['Achieve a high R-squared score on the testing set (e.g., > 0.8).', 'Low Root Mean Squared Error (RMSE) and Mean Absolute Error (MAE) on the testing set.', 'Robustness of the model to unseen data.', 'Model interpretability (understandable feature importance).', 'Efficient model training and prediction time.', 'Well-documented code and process.']}}
^C❌ Solution Quality: 0.50 (Needs Improvement)

🧠 Learning from experience...
📈 Capability Updates:
  problem_solving: 0.50 → 0.60 (+0.10)
  code_generation: 0.50 → 0.60 (+0.10)
  learning_efficiency: 0.50 → 0.70 (+0.20)
  error_handling: 0.50 → 0.60 (+0.10)
✨ Learned 3 new patterns

🔧 Attempting self-modification...
Generated improved method structure
Note: Actual self-modification requires careful implementation in production

📊 Cycle 1 Summary:
  Average Solution Quality: 0.60
  Current Capabilities: {'problem_solving': 0.6, 'code_generation': 0.6, 'learning_efficiency': 0.7, 'error_handling': 0.6}
  Total Patterns Learned: 3

==================================================
IMPROVEMENT CYCLE 2/3
==================================================

=== Iteration 6 ===
Problem: Write a function to calculate the factorial of a number
Task Analysis: {'task': 'Write a function to calculate the factorial of a number', 'analysis': {'complexity': 2, 'requiredSkills': ['Basic programming knowledge', 'Understanding of loops (iterative or recursive)', 'Basic arithmetic operations', 'Function definition and usage'], 'potentialChallenges': ['Handling edge cases (e.g., factorial of 0, negative numbers)', 'Dealing with potential overflow for large numbers (integer limits)', 'Choosing between iterative and recursive approaches (performance implications)', 'Error handling (e.g., non-integer input)'], 'recommendedApproach': {'step1': 'Define the function signature:  `factorial(n)` where `n` is the input number.', 'step2': 'Handle edge cases: Check if `n` is 0 (factorial is 1) or negative (factorial is undefined - return an error or specific value like -1).', 'step3': 'Choose an approach: \n\t* **Iterative:** Use a loop to multiply numbers from 1 to `n`. \n\t* **Recursive:** Define the factorial recursively: `factorial(n) = n * factorial(n-1)` with the base case `factorial(0) = 1`.  Consider potential stack overflow for very large numbers.', 'step4': 'Implement the chosen approach: Write the code to calculate the factorial based on the selected method.', 'step5': 'Test the function thoroughly: Test with various inputs, including 0, positive integers, and potentially negative numbers (to see how the error handling works).', 'step6': 'Optional: Add input validation to check if the input is an integer.'}, 'successCriteria': ['The function correctly calculates the factorial of non-negative integers.', 'The function handles the edge case of 0 correctly (factorial of 0 is 1).', 'The function gracefully handles negative input (e.g., throws an error or returns a specific value).', "The function's code is clean, readable, and well-documented.", 'The function passes all test cases.']}}
^CTraceback (most recent call last):